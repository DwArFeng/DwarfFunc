package com.dwarfeng.dwarffunction.threads;

import com.dwarfeng.dwarffunction.interfaces.Nameable;

/**
 * 内部线程类。
 * <p>该类在最大程度上封装了在其内部具有线程的对象。
 * <br>该类中定义了一个内部线程，并且可以对其线程调用其中的方法。
 * <br>该类中可以对其中的内部线程定义启动方法、循环方法、结束方法，并可以返回线程的状态，以及返回线程本身。
 * <br>该类的有关线程的操作方法均为线程不安全，如有必要，需要在外部进行同步方法编写。
 * @author DwArFeng
 * @since 1.8
 */
public abstract class InnerThread implements Nameable {
	
	private Thread t;
	private boolean runFlag;
	private boolean isDaemon;
	private String name;
	
	/**
	 * 生成一个默认的内部线程类。该内部线程不是守护线程，且线程名为空。
	 */
	public InnerThread(){
		this(null,false);
	}
	/**
	 * 生成一个内部线程类，其内部线程是否为守护线程由构造器指定。
	 * @param isDaemon 该内部线程是否为守护线程。
	 */
	public InnerThread(boolean isDaemon){
		this(null,isDaemon);
	}
	public InnerThread(String name){
		this(name,false);
	}
	/**
	 * 生成一个具有指定名称的内部线程，其线程是否为守护线程有构造器指定。
	 * @param isDaemon 内部线程是否为守护线程。
	 * @param name 该内部线程的名字。
	 */
	public InnerThread(String name,boolean isDaemon){
		this.runFlag = false;
		this.isDaemon = isDaemon;
		this.name = name;
	}
	
	/**
	 * 返回该内部线程类的内部线程是否为守护线程。
	 * @return 该内部线程类的内部线程是否为守护线程。
	 */
	public boolean isDaemon(){return this.isDaemon;}
	/**
	 * 指定该内部线程类的内部线程是否为守护线程。
	 * <p>如果该内部线程已经被开启，则线程在关闭后的下一次开启才会设置为该设置。
	 * @param isDaemon 该内部线程类的内部线程是否为守护线程。
	 */
	public void setDaemon(boolean isDaemon){this.isDaemon = isDaemon;}
	/**
	 * 返回该内部线程类的线程是否为活动的。
	 * @return 该内部线程类的线程是否为活动的。
	 */
	public boolean isAlive(){
		if(t == null) return false;
		return t.isAlive();
	}
	/**
	 * 启动线程。
	 * <p>如果在此之前，内部线程已经被启动，且仍未停止，则该方法无效。
	 * <p>该方法会丢弃旧的线程，指定新的线程。
	 */
	public void runThread(){
		if(isAlive()) return;
		t = createThread();
		runFlag = true;
		t.start();
	}
	/**
	 * 停止线程。
	 * <p>该方法会尽量的结束当前的线程，如果该线程在当时处于睡眠状态，则该方法会
	 * 尝试唤醒该线程，并且将其的运行标志设为<code>false</code>。该线程会在执行最后
	 * 一次循环后停止。
	 * <br>如果在此之前，线程还未启动，则该方法无效。
	 */
	public void stopThread(){
		this.runFlag = false;
		if(t != null) t.interrupt();
	}
	/**
	 * 停止线程并阻塞。
	 * <p>该方法会尝试结束当前线程，并且在该线程停止之前会一直阻塞该方法。
	 * <br>如果在停止之前，线程还未启动，则该方法无效。
	 */
	public void stopThreadAndBlock(){
		this.stopThread();
		while(isAlive());
	}
	
	/*
	 * (non-Javadoc)
	 * @see com.dwarfeng.dwarffunction.interfaces.Nameable#getName()
	 */
	@Override
	public String getName(){return this.name;}
	
	/**
	 * 线程的启动方法。
	 * <p>该方法会在该内部线程类执行<code>runThread()</code>方法之后首先进行调用。在
	 * 线程的整个生命周期内，该方法仅被调用一次。
	 */
	protected abstract void threadStartMethod();
	/**
	 * 线程的循环方法。
	 * <p>该方法会在该内部线程类执行<code>runThread()</code>方法之后，在执行完
	 * <code>threadStartMethod()</code>方法之后循环调用。
	 * <br>当该内部线程类执行<code>stopThread()</code>方法之后，会在结束完当前的循环放方法（如果
	 * 此时的方法没有执行完毕时）停止循环，并在其后执行<code>threadStopMethod()</code>方法。
	 */
	protected abstract void threadRunMethod();
	/**
	 * 线程的停止方法。
	 * <p>该方法会在该内部线程类执行<code>stopThread()</code>方法之后，在该内部线程执行完
	 * 之后作为最后一个被执行的方法执行。该程序在整个程序的生命周期内仅仅被执行一次。
	 */
	protected abstract void threadStopMethod();
	
	private Thread createThread(){
		t = new Thread(new Runnable() {
			
			@Override
			public void run() {
				threadStartMethod();
				while(runFlag){
					threadRunMethod();
				}
				threadStopMethod();
			}
		});
		if(getName() != null && getName() != "") t.setName(getName());
		t.setDaemon(isDaemon);
		return t;
	}
	
}
